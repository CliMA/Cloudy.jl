"""
  particle mass distribution module

Particle mass distribution functions for microphysical process modeling:
  - computation of moments of distributions
  - computation of densities of distributions
  - creating distributions given a set of parameters
  - creating distributions given a set of moments
"""
module Distributions

using SpecialFunctions: gamma, gamma_inc

import ForwardDiff: derivative, gradient, jacobian

# mass distributions available for microphysics
export Distribution
export Primitive
export Exponential
export Gamma
export Truncated
export Mixture

# methods that query particle mass distributions
export moment
export density

# setters and getters
export update_params_from_moments


"""
  Distribution{FT}

A particle mass distribution function, which can be initialized
for various subtypes of assumed shapes in the microphysics parameterization.
"""
abstract type Distribution{FT} end


"""
  Primitive{FT}

A particle mass distribution that has support on the positive real 
axis and analytic expressions for moments and partial moments.
"""
abstract type Primitive{FT} <: Distribution{FT} end


"""
  Exponential{FT} <: Primitive{FT}

Represents particle mass distribution function of exponential shape.

# Constructors
  Exponential(n::Real, θ::Real)

# Fields

"""

struct Exponential{FT} <: Primitive{FT}
  "normalization constant (e.g., droplet number concentration)"
  n::FT
  "scale parameter"
  θ::FT

  function Exponential(n::FT, θ::FT) where {FT<:Real}
    if n < 0 || θ <= 0
      error("n needs to be nonnegative. θ needs to be positive.")
    end
    
    new{FT}(n, θ)
  end
end


"""
  Gamma{FT} <: Primitive{FT}

Represents particle mass distribution function of gamma shape.

# Constructors
  Gamma(n::Real, θ::Real, k::Real)

# Fields

"""
struct Gamma{FT} <: Primitive{FT}
  "normalization constant (e.g., droplet number concentration)"
  n::FT
  "scale parameter"
  θ::FT
  "shape parameter"
  k::FT

  function Gamma(n::FT, θ::FT, k::FT) where {FT<:Real}
    if n < 0 || θ <= 0 || k <= 0
      error("n needs to be nonnegative. θ and k need to be positive.")
    end
    new{FT}(n, θ, k)
  end
end


"""
  Truncated{FT} <: Distribution{FT}

A particle mass distribution function with strictly compact
support on the positive real axis achieved by clipping of
left or right parts of a primitive distribution function via multiplication
by a Heaviside function.

# Constructors
  Truncated(dist::Primitive{Real}, r::Tuple{Real, Real})

# Fields

"""
struct Truncated{FT} <: Distribution{FT}
  "primitive distribution that is truncated (e.g, Exponential)"
  primitive::Primitive{FT}
  "lower boundary of support for distribution"
  rl::FT
  "upper boundary of support for distribution"
  ru::FT
  
  function Truncated(dist::Primitive{FT}, rl::FT, ru::FT) where {FT<:Real}
    if !(0 <= rl <= ru)
      error("needs 0 <= rl <= ru")
    end
    
    new{FT}(dist, rl, ru)
  end
end


"""
  Mixture{FT} <: Distribution{FT}

A particle mass distribution function that is a mixture of 
primitive or truncated subdistribution functions.

# Constructors
  Mixture(dists::Distribution{Real}...)
  Mixture(dist_arr::Array{Distribution{FT}}) 

# Fields

"""
struct Mixture{FT} <: Distribution{FT}
  "array of distributions"
  subdists::Array{Distribution{FT}}
  
  function Mixture(dists::Distribution{FT}...) where {FT<:Real}
    if length(dists) < 2
      error("need at least two subdistributions to form a mixture.")
    end
    
    new{FT}(collect(dists))
  end
end

function Mixture(dist_arr::Array{Distribution{FT}}) where {FT<:Real}
  Mixture(dist_arr...)
end


"""
  moment_func(dist, rl, ru)

  `dist` - particle mass distribution function
  `rl` - lower boundary of integration support
  `ru` - upper boundary of integration support
Retuns a function that computes the (partial) moments of `dist`.
"""
function moment_func(dist::Exponential{FT}; rl=0.0, ru=1e16) where {FT<:Real}
  # moment_of_dist = n * θ^q * Γ(q+1) * (1 - P(q+1, r1/θ) - Q(q+1, r2/θ))
  # see definition of P & Q: https://dlmf.nist.gov/8.2
  # can reuse the moments of gamma distribution
  
  moment_func_gamma = moment_func(Gamma(1.0, 1.0, 1.0), rl=rl, ru=ru)
  function f(n::FT, θ::FT, q::FT)
    moment_func_gamma(n, θ, 1.0, q) 
  end
  return f
end

function moment_func(dist::Gamma{FT}; rl=0.0, ru=1e16) where {FT<:Real}
  # moment_of_dist = n * θ^q * Γ(q+k) * (1 - P(q+k, r1/θ) - Q(q+k, r2/θ)) / Γ(k)
  # see definition of P & Q: https://dlmf.nist.gov/8.2
  if !(0.0 <= rl <= ru)
    error("needs 0 <= rl <= ru")
  end
  function f(n, θ, k, q)
    if any(n .< 0.0)
      error("n needs to be nonnegative.") 
    end
    if any(θ .<= 0.0)
      error("θ needs to be positive.")
    end
    if any(k .<= 0.0)
      error("k needs to be positive.")
    end
    lower_inc = gamma_inc.(q .+ k, rl ./ θ, 1)[1]
    upper_inc = gamma_inc.(q .+ k, ru ./ θ, 1)[2]
    n .* θ.^q .* gamma.(q .+ k) .* (1 .- lower_inc .- upper_inc) ./ gamma.(k)
  end
  return f
end

function moment_func(dist::Truncated{FT}; rl=0.0, ru=1e16) where {FT<:Real}
  # partial moment of truncated dist has 4 cases depending on r
  if rl <= dist.rl < dist.ru <= ru
    return moment_func(dist.primitive, rl=dist.rl, ru=dist.ru)
  elseif dist.rl <= rl < ru <= dist.ru
    return moment_func(dist.primitive, rl=rl, ru=ru)
  elseif rl <= dist.rl < ru <= dist.ru
    return moment_func(dist.primitive, rl=dist.rl, ru=ru)
  elseif dist.rl <= rl < dist.ru <= ru
    return moment_func(dist.primitive, rl=rl, ru=dist.ru)
  else
    return moment_func(dist.primitive, rl=0.0, ru=0.0)
  end
end 

#function moment_func(dist::Mixture{FT}; rl=0.0, ru=1e16) where {FT<:Real}
#  # mixture moment is sum of moments
#  num_pars = [nparams(d) for d in dist.subdists] 
#  part_funcs = [moment_func(d) for d in d.subdists]
#  function f(params..., q)
#    values = collect(params)
#    i = 1
#    output = 0.0
#    for (n, part_func)  in zip(num_pars, part_funcs)
#      output += part_func(values[i:i+n-1]..., q, rl=rl, ru=ru)
#      i += n
#    end
#    return output
#  end
#  return f
#end


"""
  moment(dist, q, rl, rl)
  moment(dist, q)
  
  - `dist` - distribution of which the partial moment `q` is taken
  - `q` - is a potentially real-valued order of the moment
  - `rl` - is the lower boundary of the integration interval 
  - `ru` - is the upper boundary of the integration interval 
Returns the q-th partial moment of a particle mass distribution function.
"""
function moment(dist::Distribution{FT}, q::FT, rl::FT, ru::FT) where {FT<:Real}
  moment_func(dist, rl=rl, ru=ru)(get_params(dist)[2]..., q)  
end

function moment(dist::Distribution{FT}, q::FT) where {FT<:Real}
  moment_func(dist)(get_params(dist)[2]..., q)  
end


"""
  density_func(dist)

  - `dist` - is a particle mass distribution
Returns the particle mass density function.
"""
function density_func(dist::Exponential{FT}) where {FT<:Real}
  # density = n / θ * exp(-x/θ)
  
  # can reuse the density of gamma distribution
  density_func_gamma = density_func(Gamma(1.0, 1.0, 1.0))
  function f(n, θ, x)
    density_func_gamma(n, θ, 1.0, x) 
  end
  return f
end

function density_func(dist::Gamma{FT}) where {FT<:Real}
  # density = n / θ^k / Γ(k) * x^(k-1) * exp(-x/θ)
  function f(n, θ, k, x)
    if any(x .< zero(x))
      error("Density can only be evaluated at nonnegative values.")
    end
    n .* x.^(k .- 1) ./ θ.^k ./ gamma.(k) .* exp.(-x ./ θ)
  end
  return f
end

function density_func(dist::Truncated{FT}) where {FT<:Real}
  # truncated dist density is either zero or primitive's density
  function f(args...)
    # unpack arguments appropriately
    input_args = collect(args)
    dist_params = input_args[1:end-1]
    x = input_args[end]
    
    # return zero if x is not within support range
    if 0 <= x < dist.rl || x > dist.ru
      return 0.0
    else
      return density_func(dist.primitive)(dist_params..., x)
    end
  end
  return f
end

#function density(dist::Mixture{FT}, x::FT) where {FT<:Real}
#  # mixture density is sum of densities of subdists
#  num_pars = [nparams(d) for d in dist.subdists] 
#  dens_funcs = [density_func(d) for d in d.subdists]
#  function f(params..., x)
#    values = collect(params)
#    i = 1
#    output = 0.0
#    for (n, dens_func)  in zip(num_pars, dens_funcs)
#      output += dens_func(values[i:i+n-1]..., x)
#      i += n
#    end
#    return output
#  end
#  return f
#end


"""
  density(dist, x)

  - `dist` - is a particle mass distribution
  - `x` - is a point to evaluate the density of `dist` at
Returns the particle mass density evaluated at point `x`.
"""
function density(dist::Distribution{FT}, x::FT) where {FT<:Real}
  density_func(dist)(get_params(dist)[2]..., x)
end


"""
  nparams(dist)

  - `dist` - is a particle mass distribution
Returns the number of settable parameters of dist.
"""
function nparams(dist::Primitive{FT}) where {FT<:Real}
  length(propertynames(dist))
end

function nparams(dist::Truncated{FT}) where {FT<:Real}
  length(propertynames(dist.primitive))
end

function nparams(dist::Mixture{FT}) where {FT<:Real}
  sum([nparams(d) for d in dist.subdists])
end


"""
  get_params(dist)

  - `dist` - is a particle mass distribution
Returns the names and values of settable parameters for a dist.
"""
function get_params(dist::Primitive{FT}) where {FT<:Real}
  params = Array{Symbol, 1}(collect(propertynames(dist)))
  values = Array{FT, 1}([getproperty(dist, p) for p in params])
  return params, values
end

function get_params(dist::Truncated{FT}) where {FT<:Real}
  get_params(dist.primitive)
end

function get_params(dist::Mixture{FT}) where {FT<:Real}
  params, values = Array{Array{Symbol, 1}}([]), Array{Array{FT, 1}}([]) 
  for (i, d) in enumerate(dist.subdists)
    params_sub, values_sub = get_params(d)
    append!(params, [params_sub])
    append!(values, [values_sub])
  end
  return params, values
end


"""
  update_params(dist, params)

  - `dist` - is a particle mass distribution
Returns a new distribution of same type as input with `params` as parameters.
If dist is of type `Mixture` then subdistributions are updated.
"""
function update_params(dist::Exponential{FT}, values::Array{FT}) where {FT<:Real}
  Exponential(values...)
end

function update_params(dist::Gamma{FT}, values::Array{FT}) where {FT<:Real}
  Gamma(values...)
end

function update_params(dist::Truncated{FT}, values::Array{FT}) where {FT<:Real}
  Truncated(update_params(dist.primitive, values), dist.rl, dist.ru)
end

function update_params(dist::Mixture{FT}, values::Array{FT}) where {FT<:Real}
  if length(values) != nparams(dist)
    error("length of values must match number of params of dist.")
  end
  
  # create new subdistributions one dist at a time
  i = 1
  dist_arr = Array{Distribution{FT}}([])
  for d in dist.subdists 
    n = nparams(d)
    push!(dist_arr, update_params(d, values[i:i+n-1]))
    i += n
  end

  Mixture(dist_arr)
end


"""
  update_params_from_moments(dist::Distribution{FT}, m::Array{FT}) where {FT<:Real}

  - `dist` - is a mass distirbution function
  - `m` - is an array of moments
Updates the internal parameters of the mass distribution function `dist`.
"""
function update_params_from_moments(dist::Exponential{FT}, m::Array{FT}) where {FT<:Real}
  if length(m) != nparams(dist)
    error("Number of moments must match number of distribution parameters.")
  end
  check_moment_consistency(m)
  
  # n = M_0, θ = M_1 / M_0
  n, θ = m[1], m[2] / m[1]

  update_params(dist, [n, θ])
end

#function update_params_from_moments(dist::Gamma{FT}, m::Array{FT}) where {FT <: Real}
#  if length(m) != nparams(dist)
#    error("Number of moments must be consistent with distribution type.")
#  end
#  check_moment_consistency(m)
#
#  # n = M_0
#  n = m[1]
#
#  # θ = (M_2 M_0 - M_1^2) / M_1 / M_0
#  θ = (m[3] * m[1] - m[2]^2) / m[2] / m[1]
#
#  # k = M_1^2 / (M_2 M_0 - M_1^2)
#  k = m[2]^2 / (m[3] * m[1] - m[2]^2)
#
#  update_params(dist, [n, θ, k])
#end

function update_params_from_moments(dist::Distribution{FT}, m::Array{FT}) where {FT<:Real}
  if length(m) != nparams(dist)
    error("Number of moments must be consistent with distribution type.")
  end
  check_moment_consistency(m) 

  # function to be optimized takes in vector of parameters and returns moments
  function g(x)
    moment_func(dist)(1.0, 1.0, x, 0.0)
  end

  θ = get_params(dist)[2]
  println(θ)
  println(moment_func(dist)(θ..., 0.0))
  println(g(3.0))

  ## set up jacobian of function we want to find the root of
  der = x -> derivative(g, x)
  #jac = x -> jacobian(g, x)
  println(der(3.0))

  ## get current dist parameter values and unpack into array
  #θ = reduce(vcat, get_params(dist)[2])
  #println(θ)
  #println(jac([1.0, 2.3, 5.0, 6.0, 12.0])) 
  nothing
end


"""
  check_moment_consistency(m::Array{FT})

  - `m` - is an array of moments

Checks if moments are nonnegative and whether even-ordered central moments implied
by moments vector are all positive.
"""
function check_moment_consistency(m::Array{FT}) where {FT<:Real}
  n_mom = length(m)
  # check if  moments are nonnegative
  if any(m .< 0.0)
    error("all moments need to be nonnegative.")
  end

  # check if even-ordered central moments are positive (e.g., variance, etc.)
  # non-positivity  would be inconsistent with a well-defined distribution.
  for order in 2:2:n_mom-1
    cm = 0.0
    for i in 0:order
      cm += binomial(order, i) * (-1)^i * (m[2] / m[1])^i * (m[order-i+1] / m[1])
    end
    if cm <= 0.0
      error("order-$order central moment needs to be nonnegative.")
    end
  end

  nothing
end

end #module Distributions.jl
